    def calculate_cumulative_displacement(
        date, water_mask, mask_dict, reflyr_name
    ):
        """
        Calculate cumulative displacement up to given date using shortest path
        """
        if date == date_list[0]:
            return np.zeros((rows, cols), dtype=np.float32)
        
        # Find shortest path from first date to current date
        try:
            # Finding all paths (files) in the shortest path from
            # the first date to given date
            path = nx.shortest_path(G, source=date_list[0], target=date)
        except nx.NetworkXNoPath:
            print(f"Warning: No path found to date {date}")
            return None

        # Calculate cumulative displacement along the path
        cumulative = np.zeros((rows, cols), dtype=np.float32)
        print(f'\ndate for calculating cumulative displacement: {date}')
        print(f'shortest path from {date_list[0]} to {date}')
        for i in range(len(path)-1):
            ref_date, sec_date = path[i], path[i+1]
            file = G[ref_date][sec_date]['file']	# File in the shortest path
            print(f'{i} {ref_date} to {sec_date}: {file}')	

            # Read displacement data
            data = load_gdal(file, masked=True)
            data *= phase2range

            # Apply tropospheric correction if requested
            if apply_tropo_correction and work_dir:
                print(f"\nApplying tropospheric correction to pair {ref_date}-{sec_date}")
                
                # Extract original NetCDF filename from the GDAL path string
                # Format is 'NETCDF:"path/to/file.nc":displacement'
                nc_file = file.split('"')[1]
                print('nc file: ', nc_file)
                
                try:
                    # Read parameters needed for tropo correction
                    with h5py.File(nc_file, 'r') as nc:
                        track_number = nc['identification']['track_number'][()]
                        bounding_polygon = nc['identification']['bounding_polygon'][()].decode()
                        ref_datetime = dt.strptime(nc['identification']['reference_datetime'][()].decode(),
                                                 '%Y-%m-%d %H:%M:%S.%f')
                        sec_datetime = dt.strptime(nc['identification']['secondary_datetime'][()].decode(),
                                                 '%Y-%m-%d %H:%M:%S.%f')
                        spatial_ref_attrs = nc['spatial_ref'].attrs
                        crs_wkt = spatial_ref_attrs['crs_wkt']   
                        epsg_code = crs_wkt.split('ID["EPSG",')[-1].split(']')[0]
                        epsg_str = f'EPSG:{epsg_code}'
                        GeoTransform = spatial_ref_attrs['GeoTransform']
                        frame_id = nc['identification']['frame_id'][()]
                        frame_id = 'F' + str(frame_id).zfill(5)
                        mission_id = nc['identification']['mission_id'][()]
                        ref_date = ref_datetime.strftime('%Y%m%d')  # YYYYMMDD
                        sec_date = sec_datetime.strftime('%Y%m%d')
                        unwrapper_mask = nc['unwrapper_mask'][:]

                    # Setup parameters for tropospheric correction
                    params = {
                        'track_number': track_number,
                        'bounding_polygon': bounding_polygon,
                        'ref_datetime': ref_datetime,
                        'sec_datetime': sec_datetime,
                        'GeoTransform': GeoTransform,
                        'epsg' : epsg_str,
                        'median_height' : median_height,
                        'mission_id' : mission_id,
                        'height' : data.shape[0],
                        'width' : data.shape[1],
                    }

                    # Calculate and apply tropospheric correction
                    calculated_tropo_delay = calculate_tropospheric_delay(params, work_dir)     # unit: meter
                    
                    ### code to plot the tropospheric correction
                    _data = data.copy()
                    _data[unwrapper_mask==0.] = np.nan
                    fig, ax = plt.subplots(1, 3, figsize=(15,10))
                    im0 = ax[0].imshow(_data, cmap='RdBu')
                    ax[0].set_title(f'Displacement before tropo correction \n{frame_id} {ref_date}-{sec_date}')
                    ax[0].axis('off')
                    plt.colorbar(im0, ax=ax[0], label='LOS (m)', shrink=0.2)
                    im1 = ax[1].imshow(calculated_tropo_delay, cmap='RdBu')
                    ax[1].set_title(f'Tropospheric delay \n{frame_id} {ref_date}-{sec_date}')
                    ax[1].axis('off')
                    plt.colorbar(im1, ax=ax[1], label='LOS (m)',shrink=0.2)
                    im2 = ax[2].imshow(_data - calculated_tropo_delay, cmap='RdBu')
                    ax[2].set_title(f'Displacement after tropo correction \n{frame_id} {ref_date}-{sec_date}')
                    ax[2].axis('off')
                    plt.colorbar(im2, ax=ax[2], label='LOS (m)', shrink=0.2)
                    plt.tight_layout()
                    fig.savefig(f'{work_dir}/tropo_corrected_displacement_{frame_id}_Raytracing_{ref_date}_{sec_date}.png', dpi=300, bbox_inches='tight')
                    plt.close('all')
                    del _data
                    del unwrapper_mask
                    ###

                    data -= calculated_tropo_delay      # unit: meter 
 
                except Exception as e:
                    print(f"Warning: Tropospheric correction failed for {ref_date}_{sec_date}: {str(e)}")
                    print("Continuing with uncorrected data...")

            # Apply reference point correction
            if ref_y is not None and ref_x is not None:
                data -= np.nan_to_num(data[ref_y, ref_x])
          
            # mask by specified dict of thresholds 
            for dict_key in mask_dict.keys():
                mask_lyr = file.replace(reflyr_name, dict_key)
                mask_thres = mask_dict[dict_key]
                mask_data = load_gdal(mask_lyr)
                data[mask_data < mask_thres] = np.nan
 
            # Apply water mask
            data *= water_mask

            # Add to cumulative displacement
            cumulative += data 

        # convert nans to 0
        # necessary to avoid errors with MintPy velocity fitting
        return np.nan_to_num(cumulative)
